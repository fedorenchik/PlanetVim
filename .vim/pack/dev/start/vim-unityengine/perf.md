# Performance Considerations

### [Big three for structs](http://www.somasim.com/blog/2015/08/c-performance-tips-for-unity-part-2-structs-and-enums/)
When implementing custom structs do these three things to avoid slow
garbage-generating iterations or Dictionary use:

* provide a type-specific equality comparison function via `IEquatable<T>`
* override `GetHashCode()` and `Equals()` with faster (custom) versions
* override operators `==` and `!=` to use strongly typed equality checks

### [Implement `IEqualityComparer<T>` for enum keys](http://www.somasim.com/blog/2015/08/c-performance-tips-for-unity-part-2-structs-and-enums/)
* Implement `IEqualityComparer<T>` for the enum type and pass that into the Dictionary constructor to avoid boxing.
* OR cast enums into ints and use an int-keyed dictionary.

### [Avoid UnityEvent from code](https://jacksondunstan.com/articles/3335)
* UnityEvent creates more garbage than C# `event` so only use when exposing through the inspector.


### [Unity Function Performance](https://jacksondunstan.com/articles/3605)
TODO: Rerun this test with nonempty functions.


### [Garbage generated by iteration](https://jacksondunstan.com/articles/3805)
* Iterating over arrays and `List<T>` produce no garbage.
* Iterating over `Dictionary<T>`, `HashSet<T>`, `LinkedList<T>`.
* `Dictionary<T>`, `HashSet<T>`, `LinkedList<T>`, `Queue<T>`, and `Stack<T>` only create garbage on the first iteration of each type T (not per-object).


### [Animation Blending](https://youtu.be/8VgQ5PpTqjc?t=1913)
* Layers at 0 will no execute. Layers at epsilon will.
 * Clamp your layer blend weights: `weight = weight < 0.01f ? 0.0f : weight;` This can provide big speed ups when you often have small (and imperceivable) weights (e.g., from stick input).



# Profiling

Here's some quick pointers for where to look when you find slow code.

* WillRenderCanvas 
 * See [UI profiling tools](https://unity3d.com/learn/tutorials/topics/best-practices/unity-ui-profiling-tools).
* Canvas.BuildBatch or Canvas::UpdateBatches
 * likely problem is an excessive number of Canvas Renderer components on a single Canvas: see [splitting canvases](https://unity3d.com/learn/tutorials/topics/best-practices/fill-rate-canvases-and-input#splitting-canvases).
* WaitForTargetFPS
 * Whenever we see a function called WaitForTargetFPS in the Hierarchy view, this means that our game is waiting for VSync. We do not need to investigate this function and can safely ignore it. See [Disabling VSync](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window).
* Gfx.WaitForPresent
 * If the function Gfx.WaitForPresent is taking the longest in the CPU Usage profiler, this indicates that the CPU is waiting for the GPU. This means that our game is GPU bound at this point. See [Optimizing graphics rendering in Unity games](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069).
* TempAlloc.Overflow
 * If related to animator, [indicates too many clips](https://youtu.be/8VgQ5PpTqjc?t=1882).
 * Use RuntimeOverrideControllers to unload unused data.

Otherwise, see: [Diagnosing performance problems using profiler window](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)


